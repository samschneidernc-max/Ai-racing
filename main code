import React, { useEffect, useRef, useState, useMemo } from "react";

/**
 * NeuroRacer — a tiny generational-learning racing sandbox
 * Single-file React component. No external libs. Tailwind UI classes allowed.
 *
 * How it works (short):
 * - A population of cars learns to drive a fixed track using a simple neural net
 *   and a genetic algorithm (selection + crossover + mutation).
 * - Each car sees the world through 5 distance sensors (raycasts) + its speed.
 * - The network outputs steering and throttle. Fitness rewards progress along
 *   the centerline checkpoints and staying alive.
 * - When all agents crash or a time cap hits, we evolve a new generation.
 */

export default function NeuroRacer() {
  // ==== UI State ====
  const [running, setRunning] = useState(false);
  const [generation, setGeneration] = useState(1);
  const [populationSize, setPopulationSize] = useState(60);
  const [mutationRate, setMutationRate] = useState(0.12);
  const [elitism, setElitism] = useState(4);
  const [sensorCount, setSensorCount] = useState(5);
  const [maxSimTime, setMaxSimTime] = useState(50); // seconds
  const [showSensors, setShowSensors] = useState(true);
  const [speedLimit, setSpeedLimit] = useState(3.6); // px per frame (approx m/s vibe)

  const [stats, setStats] = useState({
    alive: 0,
    best: 0,
    avg: 0,
    topLap: 0,
  });

  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const rafRef = useRef<number | null>(null);
  const simTimeRef = useRef(0);

  // ==== Track Definition ====
  // Centerline polyline points (simple squarish loop with kinks)
  const track = useMemo(() => {
    const w = 980, h = 620;
    const margin = 90;
    const pts = [
      [margin, h/2],
      [margin, margin],
      [w/2 - 120, margin],
      [w/2 + 160, margin + 20],
      [w - margin, margin + 40],
      [w - margin, h/2 - 60],
      [w - margin - 60, h - margin],
      [w/2 + 60, h - margin - 20],
      [w/2 - 220, h - margin - 40],
      [margin, h - margin],
      [margin, h/2], // close
    ];
    const width = 120; // full track width
    return { pts, width, w, h };
  }, []);

  // Build checkpoints from the centerline segments (every segment acts as a checkpoint)
  const checkpoints = useMemo(() => {
    const cps: { p: [number, number], q: [number, number] }[] = [];
    for (let i = 0; i < track.pts.length - 1; i++) {
      cps.push({ p: track.pts[i] as [number, number], q: track.pts[i+1] as [number, number] });
    }
    return cps;
  }, [track]);

  // ==== Math helpers ====
  const clamp = (v: number, a: number, b: number) => Math.max(a, Math.min(b, v));
  const lerp = (a: number, b: number, t: number) => a + (b - a) * t;
  const dist2 = (ax: number, ay: number, bx: number, by: number) => (ax-bx)*(ax-bx)+(ay-by)*(ay-by);
  const segLen = (p: [number,number], q: [number,number]) => Math.hypot(q[0]-p[0], q[1]-p[1]);

  // Distance from point to segment; returns {d, t, projx, projy}
  function pointToSeg(px:number, py:number, ax:number, ay:number, bx:number, by:number) {
    const vx = bx - ax, vy = by - ay;
    const wx = px - ax, wy = py - ay;
    const L2 = vx*vx + vy*vy || 1e-9;
    const t = clamp((wx*vx + wy*vy) / L2, 0, 1);
    const projx = ax + t*vx, projy = ay + t*vy;
    const d = Math.hypot(px - projx, py - projy);
    return { d, t, projx, projy };
  }

  // Compute distance from (x,y) to the centerline and progress along checkpoints
  function trackDistanceAndProgress(x:number, y:number) {
    let best = { d: Infinity, t: 0, seg: 0, projx: 0, projy: 0, accLen: 0 };
    let acc = 0;
    for (let i = 0; i < track.pts.length - 1; i++) {
      const p = track.pts[i] as [number, number];
      const q = track.pts[i+1] as [number, number];
      const { d, t, projx, projy } = pointToSeg(x, y, p[0], p[1], q[0], q[1]);
      if (d < best.d) best = { d, t, seg: i, projx, projy, accLen: acc + segLen(p,q) * t };
      acc += segLen(p,q);
    }
    const totalLen = totalTrackLenRef.current || 1;
    const progress = best.accLen / totalLen; // 0..1 over lap
    return { edgeDist: track.width/2 - best.d, segIndex: best.seg, tOnSeg: best.t, progress };
  }

  // Raycast sensor approximation: step along a ray until outside the track bounds
  function senseDistance(x:number, y:number, ang:number, maxDist=220, step=6) {
    let d = 0;
    while (d < maxDist) {
      const sx = x + Math.cos(ang) * d;
      const sy = y + Math.sin(ang) * d;
      const { edgeDist } = trackDistanceAndProgress(sx, sy);
      if (edgeDist < 0) return d; // we hit outside the drivable area
      d += step;
    }
    return maxDist;
  }

  // ==== Neural net ====
  type Genome = number[]; // flat list of weights

  function randn() { // small gaussian-ish
    // Box-Muller lite
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  }

  function randomGenome() {
    const input = sensorCount + 1; // sensors + speed
    const hidden = 8;
    const output = 2; // steer, throttle
    const W1 = (input + 1) * hidden; // +1 bias
    const W2 = (hidden + 1) * output;
    const total = W1 + W2;
    const g: number[] = new Array(total).fill(0).map(() => randn() * 0.7);
    return g;
  }

  function forward(genome: Genome, inputs: number[]) {
    const hidden = 8; const output = 2; const input = sensorCount + 1;
    // slice weights
    const W1 = genome.slice(0, (input + 1) * hidden);
    const W2 = genome.slice((input + 1) * hidden);
    // add bias to inputs
    const xin = [...inputs, 1];
    // hidden activations
    const h: number[] = new Array(hidden).fill(0);
    for (let i = 0; i < hidden; i++) {
      let s = 0;
      for (let j = 0; j < input + 1; j++) s += xin[j] * W1[i*(input+1) + j];
      h[i] = Math.tanh(s);
    }
    const hout = [...h, 1];
    const out: number[] = new Array(output).fill(0);
    for (let i = 0; i < output; i++) {
      let s = 0;
      for (let j = 0; j < hidden + 1; j++) s += hout[j] * W2[i*(hidden+1) + j];
      out[i] = Math.tanh(s);
    }
    // out[0]=steer (-1..1), out[1]=throttle (-1..1)
    return out;
  }

  function mutate(g: Genome, rate: number) {
    const ng = g.slice();
    for (let i = 0; i < ng.length; i++) {
      if (Math.random() < rate) ng[i] += randn() * 0.4;
    }
    return ng;
  }

  function crossover(a: Genome, b: Genome) {
    const n = a.length; const child = new Array(n);
    const cut = Math.floor(Math.random() * n);
    for (let i = 0; i < n; i++) child[i] = i < cut ? a[i] : b[i];
    return child as Genome;
  }

  // ==== Car & Population ====
  type Car = {
    x: number; y: number; angle: number;
    vx: number; vy: number;
    alive: boolean;
    genome: Genome; fitness: number; bestProgress: number; lap: number;
    nextSeg: number; // for progress bonus
    color: string;
  };

  const carsRef = useRef<Car[]>([]);
  const bestGenomeRef = useRef<Genome | null>(null);
  const totalTrackLenRef = useRef<number>(0);

  function spawnPopulation(genomes?: Genome[]) {
    const cars: Car[] = [];
    const start = track.pts[0] as [number, number];
    const heading = Math.atan2((track.pts[1][1]-start[1]), (track.pts[1][0]-start[0]));
    const pop = genomes ?? new Array(populationSize).fill(0).map(() => randomGenome());
    for (let i = 0; i < pop.length; i++) {
      // Slight position jitter so they don't stack perfectly
      const jitter = () => (Math.random()-0.5) * 8;
      cars.push({
        x: start[0] + jitter(), y: start[1] + jitter(), angle: heading,
        vx: 0, vy: 0,
        alive: true, genome: pop[i], fitness: 0, bestProgress: 0, lap: 0,
        nextSeg: 0,
        color: `hsl(${(i*47)%360} 80% 55%)`,
      });
    }
    carsRef.current = cars;
  }

  function evolve() {
    const cars = carsRef.current.slice();
    cars.sort((a,b) => b.fitness - a.fitness);
    const best = cars[0];
    bestGenomeRef.current = best.genome.slice();
    // Save best to localStorage
    try {
      localStorage.setItem("neuroracer_best", JSON.stringify(bestGenomeRef.current));
    } catch {}

    const survivors = cars.slice(0, Math.max(1, elitism)).map(c => c.genome);
    const next: Genome[] = [];
    // keep elites
    survivors.forEach(s => next.push(s.slice()));
    // fill rest via crossover of tournament selection
    function pick() {
      const k = 5;
      let bestIdx = Math.floor(Math.random()*cars.length);
      for (let i=1;i<k;i++) {
        const j = Math.floor(Math.random()*cars.length);
        if (cars[j].fitness > cars[bestIdx].fitness) bestIdx = j;
      }
      return cars[bestIdx].genome;
    }
    while (next.length < populationSize) {
      const p1 = pick();
      const p2 = pick();
      let child = crossover(p1, p2);
      child = mutate(child, mutationRate);
      next.push(child);
    }
    spawnPopulation(next);
    setGeneration(g => g + 1);
    simTimeRef.current = 0;
  }

  function resetAll() {
    setGeneration(1);
    simTimeRef.current = 0;
    bestGenomeRef.current = null;
    spawnPopulation();
  }

  // ==== Simulation ====
  useEffect(() => {
    // Precompute total track length
    let acc = 0;
    for (let i=0;i<track.pts.length-1;i++) acc += segLen(track.pts[i] as any, track.pts[i+1] as any);
    totalTrackLenRef.current = acc;
    resetAll();
    // eslint-disable-next-line
  }, []);

  useEffect(() => {
    // Re-spawn when these change significantly
    resetAll();
    // eslint-disable-next-line
  }, [populationSize, sensorCount]);

  function step(dt:number) {
    const cars = carsRef.current;
    const aliveCars = [] as Car[];
    let bestFit = 0; let sumFit=0; let topLap=0;

    for (const c of cars) {
      if (!c.alive) { sumFit += c.fitness; continue; }

      // Sense environment
      const angles = [-0.8, -0.35, 0, 0.35, 0.8]; // relative to heading
      const sensors: number[] = [];
      for (let i=0;i<sensorCount;i++) {
        const rel = angles[Math.floor(i*(angles.length-1)/(sensorCount-1||1))] || 0;
        const d = senseDistance(c.x, c.y, c.angle + rel);
        sensors.push(d / 220);
      }
      const speed = Math.hypot(c.vx, c.vy);
      const inputs = [...sensors, speed / speedLimit];
      const [steerRaw, throttleRaw] = forward(c.genome, inputs);

      const steer = clamp(steerRaw, -1, 1);
      const throttle = clamp((throttleRaw+1)/2, 0, 1); // 0..1

      // Simple dynamics
      const maxSteer = 0.07;
      c.angle += steer * maxSteer;
      const acc = 0.12 * throttle;
      c.vx += Math.cos(c.angle) * acc;
      c.vy += Math.sin(c.angle) * acc;

      // Drag + mild lateral friction
      c.vx *= 0.98; c.vy *= 0.98;
      const spd = Math.hypot(c.vx, c.vy);
      if (spd > speedLimit) {
        const scale = speedLimit / (spd + 1e-6);
        c.vx *= scale; c.vy *= scale;
      }

      c.x += c.vx; c.y += c.vy;

      // Keep inside track or die
      const { edgeDist, segIndex, progress } = trackDistanceAndProgress(c.x, c.y);
      if (edgeDist < -2) {
        c.alive = false;
      }

      // Progress fitness: reward forward movement along the lap
      // Also small living bonus
      const progBonus = progress + c.lap;
      if (progBonus > c.bestProgress) {
        c.fitness += 2.0 * (progBonus - c.bestProgress);
        c.bestProgress = progBonus;
      } else {
        c.fitness += 0.0008; // tiny survival drip
      }

      // Detect crossing from last seg to seg 0 (lap complete)
      if (c.nextSeg === segIndex) {
        c.nextSeg = (segIndex + 1) % (track.pts.length-1);
      } else if (segIndex === 0 && c.nextSeg === 0) {
        c.lap += 1; c.nextSeg = 1;
        c.fitness += 3.0; // lap bonus
      }

      if (c.alive) aliveCars.push(c);
      bestFit = Math.max(bestFit, c.fitness);
      topLap = Math.max(topLap, c.lap);
      sumFit += c.fitness;
    }

    setStats({ alive: aliveCars.length, best: bestFit, avg: sumFit / (cars.length||1), topLap });

    // End of generation conditions
    simTimeRef.current += dt;
    if (aliveCars.length === 0 || simTimeRef.current > maxSimTime) {
      evolve();
    }
  }

  function draw() {
    const canvas = canvasRef.current; if (!canvas) return;
    const ctx = canvas.getContext("2d"); if (!ctx) return;
    const { w, h, width } = track;

    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw grass
    ctx.fillStyle = "#0f172a"; // slate-900 background
    ctx.fillRect(0,0,canvas.width, canvas.height);

    // Draw track as thick polyline
    ctx.lineJoin = "round"; ctx.lineCap = "round";
    // Asphalt
    ctx.strokeStyle = "#1f2937"; ctx.lineWidth = width + 18;
    ctx.beginPath();
    for (let i=0;i<track.pts.length;i++) {
      const [x,y] = track.pts[i] as [number,number];
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    // Lane
    ctx.strokeStyle = "#374151"; ctx.lineWidth = width + 2;
    ctx.beginPath();
    for (let i=0;i<track.pts.length;i++) {
      const [x,y] = track.pts[i] as [number,number];
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    // Centerline dashed
    ctx.strokeStyle = "#9ca3af"; ctx.lineWidth = 2; ctx.setLineDash([10,12]);
    ctx.beginPath();
    for (let i=0;i<track.pts.length;i++) {
      const [x,y] = track.pts[i] as [number,number];
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Start line
    const p0 = track.pts[0] as [number,number];
    const p1 = track.pts[1] as [number,number];
    const nx = p1[0]-p0[0], ny = p1[1]-p0[1];
    const ang = Math.atan2(ny, nx) - Math.PI/2;
    ctx.save();
    ctx.translate(p0[0], p0[1]);
    ctx.rotate(ang);
    ctx.fillStyle = "#e5e7eb";
    ctx.fillRect(-track.width/2, -4, track.width, 8);
    ctx.restore();

    // Draw cars
    const cars = carsRef.current;
    const bestCar = cars.reduce((best, c) => (c.fitness > (best?.fitness||-1) ? c : best), null as Car | null);

    for (const c of cars) {
      const r = 8;
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.rotate(c.angle);
      ctx.fillStyle = c.alive ? c.color : "#111827";
      // body
      ctx.fillRect(-r, -r*0.6, r*2, r*1.2);
      // nose
      ctx.fillStyle = c.alive ? "#f9fafb" : "#374151";
      ctx.fillRect(r*0.9, -r*0.4, r*0.6, r*0.8);
      ctx.restore();

      // Sensors on best car only
      if (showSensors && bestCar && c === bestCar) {
        const angles = [-0.8, -0.35, 0, 0.35, 0.8];
        for (let i=0;i<sensorCount;i++) {
          const rel = angles[Math.floor(i*(angles.length-1)/(sensorCount-1||1))] || 0;
          const d = senseDistance(c.x, c.y, c.angle + rel);
          const sx = c.x, sy = c.y;
          const ex = sx + Math.cos(c.angle + rel) * d;
          const ey = sy + Math.sin(c.angle + rel) * d;
          ctx.strokeStyle = "#fde68a"; ctx.lineWidth = 1.5;
          ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(ex,ey); ctx.stroke();
          ctx.beginPath(); ctx.arc(ex,ey,2.2,0,Math.PI*2); ctx.fillStyle = "#fde68a"; ctx.fill();
        }
      }
    }

    // HUD overlay for best car
    if (bestCar) {
      const speed = Math.hypot(bestCar.vx, bestCar.vy);
      ctx.fillStyle = "#f3f4f6";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, monospace";
      ctx.fillText(`Best fitness: ${bestCar.fitness.toFixed(2)}  Lap: ${bestCar.lap}`, 14, 18);
      ctx.fillText(`Speed: ${speed.toFixed(2)} px/f`, 14, 34);
    }
  }

  // Main loop
  useEffect(() => {
    const tick = (t:number) => {
      if (!running) { rafRef.current = requestAnimationFrame(tick); draw(); return; }
      const dt = 1/60; // fixed step for stability
      step(dt);
      draw();
      rafRef.current = requestAnimationFrame(tick);
    };
    rafRef.current = requestAnimationFrame(tick);
    return () => { if (rafRef.current) cancelAnimationFrame(rafRef.current); };
    // eslint-disable-next-line
  }, [running, showSensors, mutationRate, elitism, maxSimTime, speedLimit]);

  // Keyboard shortcuts
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      if (e.code === "Space") { e.preventDefault(); setRunning(r => !r); }
      if (e.code === "KeyN") { evolve(); }
      if (e.code === "KeyR") { resetAll(); }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, []);

  // Load best genome
  function loadBest() {
    try {
      const raw = localStorage.getItem("neuroracer_best");
      if (!raw) return;
      const g = JSON.parse(raw);
      bestGenomeRef.current = g;
      // seed population with best + mutants
      const base = g as Genome;
      const genomes: Genome[] = [base];
      while (genomes.length < populationSize) genomes.push(mutate(base, 0.5));
      spawnPopulation(genomes);
      setGeneration(1);
      simTimeRef.current = 0;
    } catch {}
  }

  // Export best genome
  function downloadBest() {
    const g = bestGenomeRef.current || carsRef.current.sort((a,b)=>b.fitness-a.fitness)[0]?.genome;
    if (!g) return;
    const blob = new Blob([JSON.stringify(g)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = `neuroracer_genome_gen${generation}.json`;
    a.click(); URL.revokeObjectURL(url);
  }

  return (
    <div className="w-full min-h-screen bg-slate-900 text-slate-100 flex flex-col items-center">
      <header className="w-full max-w-6xl px-4 pt-6 pb-3 flex items-center justify-between">
        <h1 className="text-2xl font-bold tracking-tight">NeuroRacer <span className="text-slate-400 text-base">— Generational Learning AI</span></h1>
        <div className="flex gap-2">
          <button onClick={() => setRunning(r=>!r)} className="px-3 py-2 rounded-2xl bg-emerald-500 hover:bg-emerald-600 text-slate-900 font-semibold shadow">
            {running ? "Pause (Space)" : "Run (Space)"}
          </button>
          <button onClick={evolve} className="px-3 py-2 rounded-2xl bg-indigo-500 hover:bg-indigo-600 text-slate-900 font-semibold shadow">Next Gen (N)</button>
          <button onClick={resetAll} className="px-3 py-2 rounded-2xl bg-slate-700 hover:bg-slate-600 rounded-2xl shadow">Reset (R)</button>
        </div>
      </header>

      <section className="w-full max-w-6xl px-4 grid grid-cols-1 lg:grid-cols-4 gap-4">
        <div className="lg:col-span-3">
          <div className="rounded-3xl overflow-hidden shadow-lg ring-1 ring-slate-800">
            <canvas ref={canvasRef} width={1000} height={660} className="w-full block bg-slate-900" />
          </div>
          <p className="text-sm text-slate-400 mt-2">Tip: The yellow rays are the best car's sensors. Let a few generations run — they'll start to hug corners better.</p>
        </div>

        <aside className="lg:col-span-1 flex flex-col gap-3">
          <div className="p-4 bg-slate-800/60 rounded-3xl shadow space-y-3">
            <h2 className="font-semibold">Simulation</h2>
            <div className="grid grid-cols-2 gap-2 text-sm">
              <label className="col-span-2">Population: {populationSize}
                <input type="range" min={10} max={150} value={populationSize} onChange={e=>setPopulationSize(parseInt(e.target.value))} className="w-full"/>
              </label>
              <label className="col-span-2">Mutation: {mutationRate.toFixed(2)}
                <input type="range" min={0} max={0.6} step={0.01} value={mutationRate} onChange={e=>setMutationRate(parseFloat(e.target.value))} className="w-full"/>
              </label>
              <label>Elites: {elitism}
                <input type="range" min={1} max={12} value={elitism} onChange={e=>setElitism(parseInt(e.target.value))} className="w-full"/>
              </label>
              <label>Sensors: {sensorCount}
                <input type="range" min={3} max={9} value={sensorCount} onChange={e=>setSensorCount(parseInt(e.target.value))} className="w-full"/>
              </label>
              <label className="col-span-2">Speed cap: {speedLimit.toFixed(1)}
                <input type="range" min={2} max={6} step={0.1} value={speedLimit} onChange={e=>setSpeedLimit(parseFloat(e.target.value))} className="w-full"/>
              </label>
              <label className="col-span-2">Max sim per gen (s): {maxSimTime}
                <input type="range" min={15} max={120} value={maxSimTime} onChange={e=>setMaxSimTime(parseInt(e.target.value))} className="w-full"/>
              </label>
              <label className="col-span-2 flex items-center gap-2">
                <input type="checkbox" checked={showSensors} onChange={e=>setShowSensors(e.target.checked)} /> Show sensors
              </label>
            </div>
          </div>

          <div className="p-4 bg-slate-800/60 rounded-3xl shadow space-y-2">
            <h2 className="font-semibold">Generation</h2>
            <div className="text-sm grid grid-cols-2 gap-x-2 gap-y-1">
              <div className="text-slate-400">Gen</div><div>{generation}</div>
              <div className="text-slate-400">Alive</div><div>{stats.alive}</div>
              <div className="text-slate-400">Avg fit</div><div>{stats.avg.toFixed(2)}</div>
              <div className="text-slate-400">Best fit</div><div>{stats.best.toFixed(2)}</div>
              <div className="text-slate-400">Top lap</div><div>{stats.topLap}</div>
            </div>
            <div className="flex gap-2 pt-2">
              <button onClick={loadBest} className="px-3 py-2 rounded-2xl bg-sky-500 hover:bg-sky-600 text-slate-900 font-semibold shadow">Load Best</button>
              <button onClick={downloadBest} className="px-3 py-2 rounded-2xl bg-amber-400 hover:bg-amber-500 text-slate-900 font-semibold shadow">Export Best</button>
            </div>
          </div>

          <div className="p-4 bg-slate-800/60 rounded-3xl shadow text-sm space-y-2">
            <h2 className="font-semibold">Controls</h2>
            <ul className="list-disc list-inside text-slate-300">
              <li><span className="font-medium">Space</span>: Run / Pause</li>
              <li><span className="font-medium">N</span>: Force next generation</li>
              <li><span className="font-medium">R</span>: Reset population</li>
            </ul>
            <p className="text-slate-400">Fitness = lap progress + survival. GA uses tournament selection, 4 elites by default.</p>
          </div>
        </aside>
      </section>

      <footer className="py-6 text-xs text-slate-500">
        Built with ❤️ — single-file React. Have fun watching them learn.
      </footer>
    </div>
  );
}
